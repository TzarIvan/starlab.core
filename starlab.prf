#------------------------------- STARLAB.PRF -----------------------------------
# This is the Starlab PRoject Feature (PRF) file. It allows you to use the library
# and add plugins without having to worry too much about configuration. It is what
# allows us to say "it just works".
# 
# Editing this file should be done VERY carefully. These are some resources you 
# should be aware of
# @see http://doc.qt.digia.com/latest//qmake-advanced-usage.html
# @see http://developer.qt.nokia.com/doc/qt-4.8/qmake-variable-reference.html
# 
# @interal Meaning of $$PWD 
#   - when loaded as: load(starlab.prf) then gives the directory of this file
#   - when loaded as: CONFIG = starlab then gives the directory of this file
#-------------------------------------------------------------------------------

#--------------------------- CHECK COMPATIBILITY -------------------------------
#
# Here we make sure your system compiler/configuration is compatible with Starlab
# If this is not the case an error will be generated.
# 
# @todo perfect all the rules
# @todo add possibility to disable this check 
#-------------------------------------------------------------------------------
defineTest( checkSupportedOsAndCompiler ){
    # @todo ibraheem
    win32: return(true)
    # @todo return false if not 64 bits 
    mac: return(true)
    # @todo return false if not 32 bits see "contains(QMAKE_TARGET.arch, x86_64)"
    unix:!mac: return(true)
    return(false)
}
!checkSupportedOsAndCompiler():error(Your OS/compiler is not supported.)

#----------------------------- SETUP DEPLOY PATH -------------------------------
#
# Where will the application be deployed? The default deploy directory is the 
# starlab sources folder.
#  
# @todo fix a better deploy rule for win32. Use a system command?
# http://stackoverflow.com/questions/9228950/what-is-the-alternative-for-users-home-directory-on-windows-command-prompt
#-------------------------------------------------------------------------------
# attempt to see if user specified a path
STARLABPREFIX = $$(STARLABPREFIX)
isEmpty(STARLABPREFIX):mac:        STARLABPREFIX = $$PWD
isEmpty(STARLABPREFIX):win32:      STARLABPREFIX = $$PWD
isEmpty(STARLABPREFIX):unix:!mac:  STARLABPREFIX = $$PWD

#------------------------------- STARALB PATHS ---------------------------------
#
# Where do I go and look for libraries? This is highly platform dependant
#-------------------------------------------------------------------------------
mac:       LIBRARIESPATH  = $$STARLABPREFIX/Starlab.app/Contents/MacOS
win32:     LIBRARIESPATH  = $$STARLABPREFIX/StarlabPackage
unix:!mac: LIBRARIESPATH  = $$STARLABPREFIX/StarlabPackage
mac:       EXECUTABLEPATH = $$STARLABPREFIX/Starlab.app/Contents/MacOS
win32:     EXECUTABLEPATH = $$STARLABPREFIX/StarlabPackage
unix:!mac: EXECUTABLEPATH = $$STARLABPREFIX/StarlabPackage
mac:       PLUGINSPATH    = $$STARLABPREFIX/Starlab.app/plugins
win32:     PLUGINSPATH    = $$STARLABPREFIX/StarlabPackage/plugins
unix:!mac: PLUGINSPATH    = $$STARLABPREFIX/StarlabPackage/plugins

#------------------------------- SETUP STARLIB ---------------------------------
#
# Starlib is the core of starlab. It's a dynamic/shared library that contains all 
# the datatypes used by all the components of starlab. Here we forcefully load 
# this component. 
# 
# @internal equals skips self-dependency
# @internal $$basename cannot be put inside the equals call
#-------------------------------------------------------------------------------
PROJECTBASENAME=$$basename(_PRO_FILE_)
!equals(PROJECTBASENAME,starlib.pro){
    win32:      LIBS *= $$LIBRARIESPATH/starlib.lib
    mac:        LIBS *= -L$$LIBRARIESPATH -lstarlib
    unix:!mac:  LIBS *= -L$$LIBRARIESPATH -lstarlib
    unix:!mac:  QMAKE_LFLAGS *= -Wl,--rpath=.
    DEPENDPATH  *= $$PWD/starlib
    INCLUDEPATH *= $$PWD/starlib
}

#---------------------- SPECIFIES TEMPLATE FOR A PROEJCT -----------------------
# In your .pro file you call this function to specify what type of project you 
# are trying to build. This is done by calling one of:
# 
# StarlabTemplate(plugin)
# StarlabTemplate(sharedlib)
# StarlabTemplate(console)
# StarlabTemplate(appbunle)
#
# @todo add check to make sure nothing else is given
#-------------------------------------------------------------------------------
defineTest(StarlabTemplate){
    STARLAB_TEMPLATE=$$1 #retrieve parameter
    
    # always depend from current stuff    
    DEPENDPATH  += $$_PRO_FILE_PWD_
    INCLUDEPATH += $$_PRO_FILE_PWD_
    
    # Windows warnings
    win32: DEFINES += _CRT_SECURE_NO_WARNINGS

    equals(STARLAB_TEMPLATE,"sharedlib"){
        DESTDIR = $$LIBRARIESPATH
        LIBNAME = $$basename(_PRO_FILE_PWD_)
        TEMPLATE = lib
        CONFIG += dynamiclib
        OTHER_FILES *= *.prf
        # even though it's not a plugin this removes the *.0.0.dylib links
        mac:CONFIG += plugin
        # make mac libraries behave like in windows
        mac:LIBS += -install_name @executable_path/lib"$$LIBNAME".dylib
    }

    equals(STARLAB_TEMPLATE,"plugin"){
        QT += opengl xml
        TEMPLATE = lib
        CONFIG += plugin
        DEPENDPATH += $$_PRO_FILE_PWD_
        INCLUDEPATH += $$_PRO_FILE_PWD_
        DESTDIR = $$PLUGINSPATH
    }    

    equals(STARLAB_TEMPLATE,"appbundle"){
        DESTDIR=$$EXECUTABLEPATH
        mac{
            CONFIG *= app_bundle
            BUNDLENAME = Starlab.app
            DESTDIR=$$STARLABPREFIX
        }
    }

    equals(STARLAB_TEMPLATE,"console"){
        # QT += gui # gui has to be left as QColor and others are still used
        QT += core  
        CONFIG += console
        CONFIG -= app_bundle
        DESTDIR = $$EXECUTABLEPATH
    }

    # @internal because we are inside a function we need to "export" variables
    export(DESTDIR)
    export(TEMPLATE)
    export(CONFIG)
    export(INCLUDEPATH)
    export(DEPENDPATH)
    export(OTHER_FILES)
    export(LIBS)
    export(VERSION)
    export(QT)
}



defineTest( StarlabDepends ){
    LIBNAME=$$1
    
    # dependency specified just with the library name
    # search for PRF in the default QMAKEFEATURES paths
    # PRF takes full control of importing dependency
    DIRNAME = $$dirname(LIBNAME)
    isEmpty(DIRNAME) {
        load("$$LIBNAME".prf)
        return(true)    
    }

    # dependency specified with a relative path
    else {
        LIBRARY_DIRECTORY = $$_PRO_FILE_PWD_/$$lib
        !exists($$LIBRARY_DIRECTORY) : error("depends fail, could not find:" $$LIBRARY_DIRECTORY)
        INCLUDEPATH *= $$_PRO_FILE_PWD_/$$LIBNAME
        DEPENDPATH  *= $$_PRO_FILE_PWD_/$$LIBNAME
        LIBNAME = $$basename(LIBNAME)
        win32:      LIBS += $$LIBRARIESPATH/"$$LIBNAME".dylib
        mac:        LIBS += $$LIBRARIESPATH/lib"$$LIBNAME".dylib
        unix:!mac:  LIBS += -L$$LIBRARIESPATH -l"$$LIBNAME"
        unix:!mac:  QMAKE_LFLAGS *= -Wl,--rpath=.
    }

    export(QMAKE_LFLAGS)
    export(INCLUDEPATH)
    export(DEPENDPATH)
    export(LIBS)
}

#------------------------ STARLAB_EXTERNALS -----------------------------------
#STARLAB_EXTERNAL = $$unique(STARLAB_EXTERNAL)
#for(lib, STARLAB_EXTERNAL){
#    PRFFILENAME = $$ROOT/external/$$lib/"$$lib".prf
#    exists( $$PRFFILENAME )  : load($$PRFFILENAME)
#    !exists( $$PRFFILENAME ) : error("Cannot find '"$$lib".prf'")
#}
